# -*- coding: utf-8 -*-
"""exam08_pandas03.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GdqEbkde5XqOSbPs0KeuhJeA7ZNX2qWL
"""

import pandas as pd

df = pd.DataFrame({'ten':[10,20,30,40,50],'one':[1,-2,-4,5,6]})
df

for i in range(len(df)):
  if df.iloc[i,1] < 0:
    df.iloc[i,1] = 0
df

#위에 for문 말고 apply함수 쓰면 간단하게 됨. 이렇게 해도 됨.
df = pd.DataFrame({'ten':[10,20,30,40,50],'one':[1,-2,-4,5,6]})

def relu(value):
  if value < 0:
    value = 0
  return value

#apply는 함수를 만들어서 데이터 프레임의 모든 값을 담아내서 넣어줄 때 사용함. 자료형 map같은게 apply임
sr1 = df.one.apply(relu)  #apply한테 함수를 주면 거기에 맞는 리턴 값으로 바꿔줌, 함수를 안에 넣으면 함수의 주소를 apply에 줘서 접근하는거임.
sr1

sr2 = df.ten.apply(lambda x: x * 3 -4) #이거는 apply에 함수말고 lambda로 줬는데 함수로 주면 함수 주소에 접근해 지속적으로 사용가능하고
#지속적이 아닌 한번만 사용하고 반환할 때는 lambda를 사용함. 즉 한번만 사용하고 버릴때는 lambda사용함. lambda는 저기 인자를 저러한 수식을 적용해서 리턴해주는거임.
sr2

df1 = pd.DataFrame({'a':['a0','a1','a2','a3'], 'b':['b0','b1','b2','b3'], 'c':['c0','c1','c2','c3']}, index=[0,1,2,3])

df2 = pd.DataFrame({'a':['a2','a3','a4','a5',], 'b':['b2','b3','b4','b5',], 'c':['c2','c3','c4','c5',],'d':['d2','d3','d4','d5',]}, index=[2,3,4,5])

result1 = pd.concat([df1, df2]) #두개의 데이터프레임 합쳐줌
result1

result1 = pd.concat([df1, df2], ignore_index=True)  #인덱스 없애고 자동으로 인덱스부여해줌
result1

result1 = pd.concat([df1, df2])
result1.reset_index(drop=True, inplace=True)    #위에꺼랑 같은거임
result1

result2 = pd.concat([df1, df2], axis='columns', join='inner') #join의 디폴트가 outer임 outer은 합집합, inter은 교집합
result2

df = pd.read_csv('./datasets/titanic.csv')  #.은 현재폴더 ..은 상위폴더
df

df = df.loc[:,['Age','Sex','Pclass','Fare','Survived']]    #:만 쓰면 처음부터 끝까지, :5 처음부터 4까지, 5: 5부터 끝까지
df.head()

print(df['Pclass'].unique())
print(df['Pclass'].value_counts())

grouped = df.groupby(['Pclass'])  #'Pclass' 열을 기준으로 그룹화한 다음 그룹별로 통계를 계산할 수 있음. 그러니까 pclass 안의 항목을 기준으로 나눌수 있음
#딕셔너리는 아니라서 key로 접근이 안되지만 pclass가 가진 값을 기준으로 나누어 즉 key 별로 나눈 느낌임.
print(grouped)

grouped_df = {}     #딕셔너리 형태로 보려고 이렇게한거임
for key, group in grouped:
  print('key', key)
  print('length', len(group))
  grouped_df[key] = group   #딕셔너리 안에 넣어서 아래아래쪽보면 바로 아래처럼 말고 깔끔하게 나옴.
  print(group.head())

grouped_df.keys()

grouped_df[1]

average = grouped.mean()
average

min = grouped.min()
min

max = grouped.max()
max

#그룹화하고 그룹화한걸 보려고 이렇게 표현함
grouped_two = df.groupby(['Pclass','Sex'])
for key, group in grouped_two:
  print('key', key)
  print('length', len(group))
  print(group.head())

grouped_two.mean()    # 이런게 이중인덱스 즉 다중인덱스임 이렇게 생김

group3f = grouped_two.get_group((3,'female')) #3이고, female인 항목들을 가져오는거임
group3f

dfg = grouped_two.mean()
print(type(dfg))

dfg.loc[(1,'male')]    #다중인덱스의 경우에 tuple로

dfg.loc[1]

dfg.xs('female', level='Sex')
#xs 메서드는 데이터프레임에서 특정 레벨의 인덱스를 기반으로 선택적으로 행을 추출하는 데 사용됩니다. 주어진 코드에서는 'Sex' 레벨에서 값이 'female'인 행들을 선택하는 것으로 보입니다.

pdf1 = pd.pivot_table(df, index='Pclass', columns = 'Sex', values='Age', aggfunc='mean')
#pivot_table은 내가 원하는 테이블 만드는거임. pivot은 농구 피벗 축발 고정해서 나머지발 옮기고
#값들가지고 새로운 인덱스와 콜롬만들어 새로운 테이블 만듬. 최대값 최소값 평균 다양한걸 볼 수 있음.
pdf1

pdf2 = pd.pivot_table(df, index='Pclass', columns = 'Sex', values=['Age','Fare'], aggfunc='mean')
pdf2

pdf3 = pd.pivot_table(df, index='Pclass', columns = 'Sex', values='Age', aggfunc=['mean','sum','std'])
pdf3

pdf4 = pd.pivot_table(df, index='Pclass', columns = 'Sex', values='Survived', aggfunc='mean')
pdf4

pdf4 = pd.pivot_table(df, index=['Pclass','Sex'], columns = 'Survived', values=['Age','Fare'], aggfunc=['mean','max'])
pdf4

df_teenage = df.loc[(df.Age>=10) & (df.Age<20)]     #내가 원하는 것만 보는 방법: 조건인덱싱
df_teenage.head(30)

df_teenage.info()

df_teenage.Survived.mean()

df_teenage.Survived.sum()

titanic = pd.read_csv('./datasets/titanic.csv')
titanic.info()

isin_filter = titanic['SibSp'].isin([2,4,5])  #저기 리스트 안에 특정값인지 보려할때 isin사용함. 특정값이면 True 아니면 False
isin_filter

df_isin = titanic[isin_filter]
df_isin

df_sibsp245 = titanic[(titanic.SibSp == 2) | (titanic.SibSp == 4) | (titanic.SibSp == 5)]
df_sibsp245

df_ms = df.loc[(df.Age>=20) & (df.Age<30) &(df.Sex == 'male')]
df_ms.head(30)

df_ms.Survived.mean()

df_ms.Survived.sum()

