# -*- coding: utf-8 -*-
"""exam06_pandas01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tRCnYlKZmo-jYYEHnzoShoH8d6yooQuN

##Pandas 실습

##DataFrame

데이터프레임(DataFrame)과 시리즈(Series)는 모두 판다스(Pandas) 라이브러리에서 제공되는 데이터 구조입니다.

데이터프레임은 표처럼 인덱스와 columns 제외하고 안에 값이 여러 행과 열로 구성된거고
시리즈는 인덱스와 columns 제외하고 안에 값이 여러개의 행과 하나의 열로 구성된거임.

dataset은 한개의 행에 여러열들의 값이 들어가있는거고
datasets는 여러개의 행에 여러개의 열들에 값이 들어간거임.
데이터셋과 셋츠는 모두 데이터 프레임임

데이터프레임: 여러 시리즈를 열로 갖는 2차원 데이터 구조로, 각 열은 서로 다른 데이터 타입을 가질 수 있습니다.

시리즈: 하나의 열을 가지는 1차원 데이터 구조로, 동일한 데이터 타입을 갖습니다.
"""

import pandas as pd

df = pd.DataFrame([[15,'남','영훈중'],[17,'여','성암중']],index=['서준','동연'],columns=['나이','성별','학교'])
df

df.index

df = df.rename(index={'서준':'학생1','동연':'학생2'}) #서준을 학생1로 바꾸고 동연을 학생2로 바꿈, 이렇게 원래 이름을 숨기는게 익명화임.
df    #아래처럼 나온게 데이터프레임이고 datasets임 학생1만나온다면 dataset임

df = df.rename(columns={'나이':'연령'})
df

df1 = df['연령']   #컬롬인덱싱해서 한개의 콜롬을 인덱싱함 #[]이거 하나만 쓰면 시리즈이고 [[]]이렇게 두번쓰면 데이터프레임만드는거임
df1 #아래처럼 나오는게 시리즈임.  #인덱싱이란게 파이썬 리스트로 예를 들면 리스트 만들면 인덱스번호가 부여되는 이런게 인덱싱임
#인덱싱을 하면 수정도 가능함 파이썬의 리스트에서 수정하던거 생각하면 됨.

print(type(df1))  #데이터 타입이 시리즈로 나옴

df2 = df[['연령','성별']] #컬롬인덱싱을 리스트화해서 여러개의 컬롬을 인덱싱함 #데이터프레임만들려고 [[]] 이렇게 사용함.
print(type(df2))
print(df2)    #아래는 행이 두줄이니 데이터프레임임

df3 = df.iloc[0]  #[]한개 썻으니 시리즈임.
df3

df4 = df.loc['학생1']   #iloc 인덱스번호를 써야함. loc 쓸때는 인덱스명을 써야함. 결과는 같음
df4

df.iloc[0,0]    #lioc[0,0] = 99 이렇게 하면 99값이 0,0에 들어가고 값은 안보여주고 iloc[0,0] 이렇게 끝내면 해당 위치 값 나타남

df.iloc[0,1]

df.iloc[0,2]

df.loc['학생1','학교']

#위는 인덱싱한거임.
#슬라이싱 = 구간으로 인덱싱하는거
df.iloc[0,0:2]

df.loc['학생1','연령':'성별']

#파이썬의 기본 자료형인 리스트,튜플,셋,딕셔너리는 모두 1차원 즉 인덱스 하나로 값을 찾음
#데이터프레임은 표라서 2차원 즉 인덱스와 콜롬으로 값을 찾음.
df.loc['학생3'] = [18,'남','신일중']    #이런식으로 인덱싱추가하는거임.
df.loc['학생4'] = [14,'여','풍문중']
df

df1 = df.drop(['학생3'], inplace=False, axis='rows')
#inplace=False가 디폴트로 false 하면 df를 그대로 복사해서 학생3을 드랍해서 df1에 넣어줌 즉 원본을 유지하고 사본을 복사해서 수정해서 넣어줌
#inplace=True을 하면 df의 학생3을 드랍하여 수정함 즉 원본을 수정해서 리턴함.
#axis='rows' 여기서 rows가 디폴트로 rows 대신 0을 줘도 됨 인덱스 즉 행을 지울때는 0, 콜럼 즉 열을 지울때는 1을 줌('columns')
df1

#컬롬 인덱싱 추가
df['학년']= 3 #하나만 적었지만 나머지 인덱스에 모두 채워짐
df

df['키'] = [150,160,170,180]    #값을 이렇게 줄꺼면 인덱스의 개수를 맞춰서 줘야함 그러나 하나만 적으면 같은 값 전체 다 들어감
df

df1 = df.drop(['학년'], axis ='columns', inplace = False)
df1

df

df1 = df[['연령','성별','학교','키']]   #위에 드랍한거랑 같은 방식임 표시할 부분만 작성해서 빼려는 부분 뺀거임.
df1

exam_data = {'이름': ['경석', '연주', '선희'],
             '수학': [90,85,70],
             '영어': [98,88,78],
             '음악': [90,89,88],
             '체육': [88,78,69]}
df = pd.DataFrame(exam_data)
df.set_index('이름',inplace = True)   #이름 안에 있는 내용을 인덱스로 쓰겠다는 의미임
df

df.shape

df.iloc[0,3] = 90
df

df.loc['경석','체육'] = 100
df

df.loc['경석',['영어', '체육']] = 120 , 130 #값을 그냥 120 이렇게 주면 둘다 120들어가고 리스트로 120, 130 주면 리스트 값 들어감
df

df = df.transpose()   #df.T 이것과 같은 역할임 행과 열을 바꿔줌
df

df=df.T
df

df.loc['선희','음악'] = 89
df

ndf1 = df.set_index('음악') #음악의 값들을 인덱스로 사용함
ndf1

ndf1.loc[89]    # = 90 이렇게 값을 안넣었기 때문에 인덱스가 99인 값들을 나타냄

ndf2 = df.set_index(['음악','수학'])
ndf2

ndf2.loc[(89,70)]

ndf2.iloc[1]

df

ndf3 = df.reset_index().set_index(['음악'])
#reset 저거는 위에 인덱스인 이름을 리셋해서 이름을 다시 콜럼으로 만들어줌 즉 인덱스를 지워주고 그 후에 set으로 새로운 인덱스를 설정함
#어떤함수를 실행하고 어떤함수가 리턴하는값에 어떤것을 하고 이런걸 파이프라이닝이라함. 이것을하기위해서 리턴값이 필요함
ndf3

ndf = df.reindex(['학생1','학생2','학생3'])
#re index로 보면되는데 인덱스를 바꿔주는데 기존 인덱스를 바꿔주는게 아니고 새로운 인덱스를 추가해서 값이 없는거임
ndf

ndf1 = df.reindex(list(df.index) + ['학생1','학생2','학생3'], fill_value = 0)
#기존거 유지하고 추가하려하면 이렇게하면됨
#fill_value를 하면 빈 값이 0으로 채워짐
ndf1

#정렬
ndf = df.sort_index(ascending = False )   #인덱스 순으로 정렬함. 한글순으로 내림차순함.
#오름차순 ascending = True 이게 디폴트임 False를 하면 내림차순 됨
ndf

ndf = df.sort_values(by='영어', ascending = True) #영어 값을 기준으로 내림차순
ndf

#index나 value는 행 기준으로 정렬한거임 콜롬인 열은 딱히 정렬이 필요없고 굳이한다면 아래처럼하면됨
list(df.columns)

columns = list(df.columns)
columns.sort()

ndf = df[columns]
ndf

#시리즈
sr = pd.Series([1,2,3,4,5], index=['a','b','c','d','e'])
sr

sr[1]

student1 = pd.Series({'국어':20, '영어':90})  #시리즈를 딕셔너리로 주면 키가 인덱스로 벨류가 값으로 들어감
student1

student2 = pd.Series([10,20,20,40])  #시리즈를 리스트로 주면 값으로 들어감
student2

"""리스트는 곱하기는 됨 여러번 이어붙이면 되기때문에 그래서 더하기도 됨 그러나 빼기 나누기 이런건 불가능함
데이터프레임은 다 계산가능함.
"""

a=[1,2,3]
b=[4,5,6]
c = a+b
print(c)
d = a*5
print(d)
#e = a-b 이거 불가능
#e = a/b 이것도 불가능

import numpy as np

#넘파이(행렬) 연산
a = np.array([1,2,3])
b = np.array([4,5,6])
print(a)    #np는 행렬이라서 ,가 사라져서 1 2 3 이렇게 나옴 리스트는 ,가 있음
print(type(a))
c = a*b
print(c)
#행렬이기 때문에 더하기 빼기 곱하기 나누기 모두 가능함 리스트는 그냥 모음이라고 보면 되서 덧붙이고 이런거만 가능한거임

#시리즈 연산
percentage = student1 / 100
percentage

student3 = pd.Series({'영어':40, '수학':80, '국어':80})  #시리즈는 인덱스 기준으로 더해줌 np.array는 자리 기준으로 더해줌
student3

student1 +student3
#st1은 국어20 영어 90 순서이고 st2는 영어 40 수학 80 국어 80 순서임 이렇게 순서 달라도 인덱스에 맞춰서 더해진다는거임

#수학은 한쪽밖에 없어서 nan이 나오는데 fill_value 넣으면 해결됨
sr1 = student1.add(student3, fill_value=0)
sr1

#데이터프레임연산(시리즈와 마찬가지로 인덱스와 콜럼에 맞춰 저장됨)
ndf = df + 100
ndf

ndf2 = ndf - df
ndf2

#csv 파일로 저장
df.to_csv('./df_sample.csv' )   #csv파일로 저장하기위해 to_csv을 적고 .은 현재폴더를 의미하고 /이후에 내가저장하려는 이름을 적으면됨
#csv는 ,으로 구분해 놓은 파일이라 columns seperate value 이고 tsv는 tap seperate value라서 tap으로 구분함

"""![image.png](data:image/png;base64,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)"""

df1 = pd.read_csv('./df_sample.csv')  #파일 불러오는 방법임
df1
#저장될 때 어떤게 인덱스고 어떤게 콜롬이다 이런게 없기 때문에 그냥 순서대로 내용이 ,로 구분하며 저장되서 불러와져서 인덱스가 따로 적혀있는거임

#그래서 인덱스표시를 해야함
df2 = pd.read_csv('./df_sample.csv', index_col='이름') #이름을 인덱스로 한다는거고 이거안할거면 set_index로 인덱스설정해주면됨.
df2

df1.to_csv('./df_sample2.csv')  #위처럼 index_col이렇게 인덱스 변환하지 않고 저장하면 0,1,2, 이런 인덱스가 추가되어 귀찮아짐

df3 = pd.read_csv('./df_sample2.csv') #0,1,2 있는데 또 0,1,2 추가됨
df3

df1.to_csv('./df_sample3.csv', index = False)  #그래서 저장할 때 index= False이렇게하면 인덱스인 0,1,2 없어진채로 됨

df4 = pd.read_csv('./df_sample3.csv', index_col=0) #이렇게 불러오면 인덱스 추가하지 않고 불러와짐
df4

#json 파일로 저장
df.to_json('./df_sample.json', force_ascii = False)  #json 파일로 저장한거임 근데 아스키코드로 저장되서 false하면 해결됨
#웹에서 데이터 크롤링할 때 json파일이 많음 그리고 웹에서 서비스할 때 json파일을 많이씀
#pandas에서는 기본적으로 json으로 저장하고 불러오는기능을 제공함

ndf1 = pd.read_json('./df_sample.json') #json은 주석 추가안되고 잘 불러옴, ascii 이거 안해도 잘 불러와짐
ndf1

#엑셀 파일로 저장
df.to_excel('./df_sample.xlsx')

ndf2 = pd.read_excel('./df_sample.xlsx', index_col=0) #엑셀도 인덱스가 추가되서 나와서 뒤에꺼 씀
ndf2

#html 문서 : 웹페이지로 보는 모든게 html 이고 개발자 도구 안에 있는 코드들이 보여지는걸 만드는 코드들임.
tables = pd.read_html('https://www.w3schools.com/html/html_tables.asp')
print(type(tables))
print(len(tables))
tables[0]

